---
title: "notes - 1/28"
format: html
editor: visual
---

# Notes 1/28

**Five Number Summary** is *min, max, 1st, 2nd, and 3rd quartiles*

### Challenge

Number of variables: 16

Number of observations: 248

Number of countries: 248

Densest country: Macau

# Notes 1/30

``` r
file2 <- file.choose()
d2 <- read_csv(file2, col_names = TRUE)
d2$population
d2$area
d2$density <- d2$population / d2$area
d2 <- d2 %>%
  arrange(desc(density))
##requires read_csv to work properly
```

Important to understand the difference between a **data frame** (data arranged into a two dimensional table)and a **tibble** (list of vectors)

-   Tibbles don't work with as many functions as data frames, so those may cause more errors. However, certain functions work only on tibbles

    -   Most sub-setting works on both though

-   Tibbles are more manageable for working with in general (Tony's preference)

Useful functions for getting a grasp of the data you just freeking imported

``` r
head()
tail()
colnames()
rownames() ##only works with df
str()
glimpse()
dim()

attach() #allows R to know which variable you are referring to without specifying the data frame
with() #accomplishes a simular goal
```

Summaries for variables

``` r
summary() #gives the 5-number summary for each variable plus its class & mode if applicable
skim() #more cleaned up version of summary()
```

Boxplots & Sexy Boxplots (stripplots)

``` r
boxplot(log(d3$Body_mass_female_mean))
stripchart(log(d3$Body_mass_female_mean),
           method = "jitter",
           col = "blue",
           vertical = TRUE,
           add = TRUE)
boxplot(log(d3$Body_mass_female_mean) ~ d3$Family)
stripchart(log(d3$Body_mass_female_mean) ~ d3$Family,
           method = "jitter",
           col = "blue",
           vertical = TRUE,
           add = TRUE)
```

ggplot2 and its mysteries

``` r
p <- ggplot(data = d3,
       aes(x = "", y = log(d3$Body_mass_female_mean))) + 
  geom_boxplot(na.rm = TRUE) + 
  geom_jitter( color = "blue", width = 0.1)
```

# Notes 2/4

Scatterplot

``` r
library(tidyverse)
d <- read_csv("/Users/juneburke/Downloads/KamilarAndCooperData.csv", col_names = TRUE)
attach(d)
(p <- ggplot(data = d, aes(x = log(Body_mass_female_mean),
                          y = log(Brain_Size_Female_Mean))) + 
  geom_point(na.rm = TRUE)) ##surrounding it will make the plot automatically appear
str(p)
```

Adding stuff

``` r
(p <- ggplot(data = d, aes(x = log(Body_mass_female_mean),
                          y = log(Brain_Size_Female_Mean))) + 
  geom_point(na.rm = TRUE) + 
    geom_smooth(method = "lm", na.rm=TRUE, color = "pink") +
    geom_vline(xintercept = 7)+
    geom_hline(yintercept = 3)+
    geom_point(data = d, aes( x=log(Body_mass_female_mean),y=log(Body_mass_male_mean)))+
    geom_smooth(data = d, aes(
      x=log(Body_mass_female_mean), 
      y=log(Body_mass_male_mean)
      ), method = "lm", na.rm = TRUE, color = "cyan"))
install.packages("cowplot")
library(cowplot) 
plot_grid()#lets you load multiple plots together
```

**Data wrangling**

``` r
filter() #extracts rows that meet logical criteria (exports as tabular data)
select() #extract columns as a table (exports as tabular data)
arrange() #order rows by values of a column/columns from low to high
  ##adding desc() switches the order
group_by() #creates a table grouped by a particular column
  ##piping helps to simplify this process
summarize() #gets summaru statistics for a certain column as a vector
mutate() #creates new variables within a dataframe
```

*Examples*

``` r
s <- select(d, Family, Genus, Body_mass_male_mean)
s <- arrange(d, Family, Genus, desc(Body_mass_male_mean))
s <- summarize(
  group_by(d, Family),
  avgF = mean(Body_mass_female_mean, na.rm = TRUE)
)
```

**Flow Control & Looping**

``` r
if () else ()
ifelse()
if_else()
```

# Notes 2/11

Flow Control and Conditional Statements

``` r
#looping
for (i in 1:10) {
  print(i)
}

i <- 1
while (i <= 10) {
  print(1)
  i <- i+1
}
```

### Joins

An inner join connects along a particular index, basically removing anything that doesn't match across both tables

An outer left join creates a NA cell if there is no info in the right table that matches the left table and ignores vice versa from the left table.

An outer right join does the opposite and a full outer does both

``` R
inner <-inner_join(c, p, by = c("fullName" = "First Author"))
left <- left_join(c,p, by = c("fullName" = "First Author"))
right <- right_join(p,c, by = c("First Author" = "fullName"))
find_pubs <- tibble(fullName = c("Abbott, David H"))
inner2 <- inner_join(find_pubs,p, 
                     by = c("fullName" = "First Author"))
##fuzzy joins - not exact uses a lot of regular expressions
find_pubs2 <- tibble(partialName = c("^Abbott"))
inner_fuzzy <- regex_inner_join(p,find_pubs2, by = c("First Author" = "partialName"))
find_pubs3 <- tibble(partialName = c("^Mea", "ony$"))
inner_fuzzy2 <- regex_inner_join(p, find_pubs3, by = c("First Author" =
                                                       "partialName"))
```

"\^start" or "end\$" = regular expression. Allows for fuzzy connections (no longer case sensitive and has some leeway

### Functions

``` R
##template
my_function <- function(<argument list>){
<<function code>>
return(<value>)
}
#example
```
